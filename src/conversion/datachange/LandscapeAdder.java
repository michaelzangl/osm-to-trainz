package conversion.datachange;

import java.util.HashSet;
import java.util.Iterator;

import conversion.ConversionData;
import conversion.datachange.geometry.Polygon;
import conversion.datachange.geometry.SimplePolygon;
import data.osm.OsmWay;
import data.osm.OsmWaySegment;
import data.osm.Propertyable;
import data.osm.SimpleProperties;
import data.position.local.LocalPoint;

/**
 * This class adds auto-generated landscpae types, e.g. under railway tracks.
 * 
 * @author michael
 */
public class LandscapeAdder {
	private static final Propertyable RAILWAY_PROPS = new SimpleProperties(
	        "landuse", "railway", //
	        "trainz:autogenerated", "yes");
	private static final Propertyable RIVERBED_PROPS = new SimpleProperties(
	        "landuse", "riverbed", //
	        "trainz:autogenerated", "yes");
	private static final Propertyable STREETGROUND_PROPS =
	        new SimpleProperties("landuse", "streetground", //
	                "trainz:autogenerated", "yes");
	private static final double AREASIZE_END = 3;
	private static final double AREASIZE_SIDEWARD = 6;
	private static final HashSet<String> HIGHWAYS = new HashSet<String>();
	static {
		HIGHWAYS.add("motorway");
		HIGHWAYS.add("motorway_link");
		HIGHWAYS.add("trunk");
		HIGHWAYS.add("trunk_link");
		HIGHWAYS.add("primary");
		HIGHWAYS.add("primary_link");
		HIGHWAYS.add("secondary");
		HIGHWAYS.add("secondary_link");
		HIGHWAYS.add("tertiary");
		HIGHWAYS.add("residential");
		HIGHWAYS.add("raceway");
	}

	private final ConversionData data;

	public LandscapeAdder(ConversionData data) {
		this.data = data;
	}

	public void addLandscapes() {
		for (OsmWay way : data.getOsmData().getWays()) {
			if (!way.isArea()) {
				addLandscapeFor(way);
			}
		}
	}

	// TODO: test if this is even needed, or if there already is this ground
	// under the way.
	private void addLandscapeFor(OsmWay way) {
		Propertyable landscapeType = getLandscapeProperties(way);
		if (landscapeType != null) {
			Iterator<OsmWaySegment> it = way.getSegments();
			while (it.hasNext()) {
				OsmWaySegment segment = it.next();
				Polygon poly = getAreaForSegment(segment);
				data.getLandscape().addPolygon(landscapeType, poly);
			}
		}
	}

	private Polygon getAreaForSegment(OsmWaySegment segment) {
		LocalPoint start = data.getConverter().toLocal(segment.getStart());
		LocalPoint end = data.getConverter().toLocal(segment.getEnd());

		double forwardx = (start.getX() - end.getX());
		double forwardy = (start.getY() - end.getY());
		double length = Math.hypot(forwardx, forwardy);

		if (length > 0) {
			forwardx /= length;
			forwardy /= length;
		}

		double dx1 = forwardx * AREASIZE_END;
		double dx2 = forwardy * AREASIZE_SIDEWARD;
		double dy1 = forwardy * AREASIZE_END;
		double dy2 = -forwardx * AREASIZE_SIDEWARD;

		LocalPoint[] points = new LocalPoint[4];
		points[0] =
		        new LocalPoint(start.getX() + dx1 + dx2, start.getY() + dy1
		                + dy2);
		points[1] =
		        new LocalPoint(start.getX() + dx1 - dx2, start.getY() + dy1
		                - dy2);
		points[2] =
		        new LocalPoint(end.getX() - dx1 - dx2, end.getY() - dy1 - dy2);
		points[3] =
		        new LocalPoint(end.getX() - dx1 + dx2, end.getY() - dy1 + dy2);

		return SimplePolygon.fromArray(points);
	}

	private Propertyable getLandscapeProperties(OsmWay way) {
		if (way.getProperty("railway") != null) {
			if (!way.isBridge() && !way.isTunnel()) {
				return RAILWAY_PROPS;
			}
		} else if (way.getProperty("waterway") != null) {
			if (!way.isBridge() && !way.isTunnel()) {
				return RIVERBED_PROPS;
			}
		} else if (HIGHWAYS.contains(way.getProperty("highway"))) {
			if (!way.isBridge() && !way.isTunnel()) {
				return STREETGROUND_PROPS;
			}
		}
		return null;
	}
}
